# 分散式下載與任務協調設計討論

> 建立日期：2026-01-19
> 狀態：規劃討論中

---

## 背景

目前腳本用戶各自獨立運作，當多人同時訪問同一個頁面時，可能產生重複工作。本文探討如何優化這個流程。

---

## 核心問題

### 問題一：重複下載

```
場景：A、B、C 同時訪問頁面 X（資源站尚無備份）

目前行為：
  A 下載碎片 1,2,3,4,5... → 上傳
  B 下載碎片 1,2,3,4,5... → 上傳（重複）
  C 下載碎片 1,2,3,4,5... → 上傳（重複）

問題：浪費頻寬、伺服器收到重複資料
```

### 問題二：斷點續傳

```
場景：A 分段上傳到一半跑掉

目前疑問（待確認）：
  A 上傳碎片 1 → 離開
  B 來了 → 是否要重新下載碎片 1？還是可以從碎片 2 開始？

理想行為：
  伺服器記住已收到碎片 1
  B 來了 → 從碎片 2 繼續
```

### 問題三：閒置資源利用

```
場景：用戶 N 開了 lurl 頁面但在逛其他地方

機會：
  N 的頁面還開著 → 可以讓他幫忙下載其他任務
  類似「志願運算」的概念
```

---

## 可收集的用戶指標 (Metrics)

透過 API 可取得的資訊：

| 指標 | 用途 | 取得方式 |
|------|------|----------|
| 網路速度 | 分配任務量 | `navigator.connection.downlink` |
| 連線類型 | 判斷穩定度 | `navigator.connection.effectiveType` |
| 設備記憶體 | 判斷處理能力 | `navigator.deviceMemory` |
| CPU 核心數 | 判斷處理能力 | `navigator.hardwareConcurrency` |
| 頁面可見性 | 判斷是否活躍 | `document.visibilityState` |
| 電量狀態 | 避免耗盡電池 | `navigator.getBattery()` |

### 網路速度評估

```javascript
// 可在腳本中執行
const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
if (connection) {
  const metrics = {
    downlink: connection.downlink,        // 預估下載速度 (Mbps)
    effectiveType: connection.effectiveType, // '4g', '3g', '2g', 'slow-2g'
    rtt: connection.rtt,                  // 往返延遲 (ms)
    saveData: connection.saveData         // 用戶是否開啟省流量
  };
}
```

---

## 設計方案

### 方案 A：伺服器協調 + 任務鎖

```
流程：
1. A 訪問頁面 X → 通知伺服器「我要處理 X」
2. 伺服器記錄：X 正在處理中 (by A, started: 10:00:00)
3. B 訪問頁面 X → 伺服器回應「A 在處理，預計 30 秒」
4. B 選擇：等待 / 自己來 / 幫忙處理其他碎片

資料結構：
┌─────────────────────────────────────────────┐
│ downloadingTasks: Map                       │
│ ├─ pageUrl: "https://lurl.cc/xxx"          │
│ │   ├─ startedBy: "visitor_abc"            │
│ │   ├─ startTime: 1705641600000            │
│ │   ├─ fragments: [1,2,3] (已收到)          │
│ │   ├─ totalFragments: 10                  │
│ │   └─ helpers: ["visitor_def"] (協助者)    │
└─────────────────────────────────────────────┘
```

### 方案 B：碎片級協調

```
流程：
1. A 開始處理 X，負責碎片 1-5
2. B 加入，伺服器分配碎片 6-10
3. 各自上傳完成的碎片
4. 伺服器收齊後拼裝

優點：真正的分工合作
缺點：實作複雜、需要碎片資訊同步
```

### 方案 C：持久化工作者 (Worker Pool)

```
概念：
用戶開啟 lurl 頁面後，即使在瀏覽其他內容，
該頁面仍可作為「工作者」接受任務。

流程：
1. 用戶 N 訪問 lurl.cc/browse
2. 頁面建立 WebSocket 連線
3. N 去逛 Dcard 了（lurl 頁面仍開著）
4. 伺服器有新任務 → 推送給 N
5. N 的 lurl 頁面背景執行下載
6. 完成後上傳

技術需求：
- WebSocket 長連線
- 背景執行（需處理瀏覽器限制）
- 任務佇列管理
- UI 提示「正在背景協助處理...」
```

---

## 使用者體驗設計

### 等待畫面

```
┌──────────────────────────────────────┐
│  🔄 資源正在準備中...                │
│                                      │
│  其他用戶正在處理這個資源            │
│  預計等待時間：約 25 秒              │
│                                      │
│  [████████░░░░░░░░] 45%              │
│                                      │
│  ┌─────────────────────────────────┐ │
│  │ 💡 小提示                       │ │
│  │ 保持此頁面開啟可以幫助其他人    │ │
│  │ 更快取得過期資源！              │ │
│  └─────────────────────────────────┘ │
│                                      │
│  [ 我要自己下載 ]  [ 繼續等待 ]      │
└──────────────────────────────────────┘
```

### 背景工作者 UI

```
┌──────────────────────────────────────┐
│  LurlHub                    [最小化] │
├──────────────────────────────────────┤
│  🟢 連線中 - 背景協助模式            │
│                                      │
│  已協助處理：3 個資源                │
│  節省社群頻寬：約 45 MB              │
│                                      │
│  目前任務：無                        │
│  ──────────────────────────          │
│  📊 本週貢獻排行                     │
│  1. user_xxx - 150 個資源            │
│  2. user_yyy - 89 個資源             │
│  3. 你 - 45 個資源                   │
│                                      │
│  [ 暫停協助 ]  [ 設定 ]              │
└──────────────────────────────────────┘
```

---

## 風險與處理

| 風險 | 影響 | 處理方式 |
|------|------|----------|
| 工作者斷線 | 任務中斷 | 超時自動釋放，重新分配 |
| 任務鎖死鎖 | 永久阻塞 | 設定最大等待時間 (60s) |
| 惡意用戶 | 上傳錯誤資料 | 校驗機制（hash 比對） |
| 瀏覽器限制 | 背景執行被暫停 | Service Worker / 提示用戶 |
| 隱私疑慮 | 用戶不信任 | 透明說明、可選退出 |

---

## 實作優先順序

### Phase 1：統計與評估
- [ ] 加入重複請求統計
- [ ] 收集用戶網路指標
- [ ] 評估實際重複率

### Phase 2：簡單任務鎖
- [ ] 實作 `downloadingTasks` Map
- [ ] 「有人在處理」提示
- [ ] 超時自動釋放

### Phase 3：斷點續傳
- [ ] 記錄已收到的碎片
- [ ] 新用戶從斷點繼續

### Phase 4：持久化工作者
- [ ] WebSocket 連線管理
- [ ] 背景任務推送
- [ ] 工作者 UI

### Phase 5：進階功能
- [ ] 碎片級分工
- [ ] 貢獻排行榜
- [ ] 獎勵機制

---

## 待確認事項

1. **目前碎片上傳機制**：是否已支援斷點？A 上傳一半跑掉，資料是否保留？
2. **用戶規模預估**：預期同時在線人數？
3. **碎片大小**：每個碎片多大？總共幾個碎片？
4. **瀏覽器限制**：背景頁面的執行限制如何處理？

---

## 相關連結

- [WebRTC DataChannel](https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel) - P2P 傳輸
- [Service Worker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API) - 背景執行
- [Page Visibility API](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API) - 頁面可見性
- [Network Information API](https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API) - 網路狀態

---

## 討論紀錄

### 2026-01-19
- 初步討論分散式下載概念
- 提出伺服器協調 vs P2P 方案
- 討論用戶指標收集可能性
- 提出持久化工作者概念
- 決定先做統計評估實際需求
